{
  "repo_notes": [
    {
      "content": "BugTraceAI is a monorepo with 3 submodules: BugTraceAI-CLI (autonomous scanner), BugTraceAI-WEB (web dashboard), and BugTraceAI-Launcher (Docker deployment wizard). The CLI is the core — it runs AI-powered security scans autonomously. The WEB provides a browser UI that connects to the CLI API. The Launcher deploys both via Docker with a single command. All scan data lives in SQLite (CLI side). WEB uses PostgreSQL only for its own local data (chats, settings). They work autonomously OR together."
    }
  ],
  "pages": [
    {
      "title": "Overview",
      "purpose": "Introduce BugTraceAI as an autonomous AI-powered security scanning platform. Explain what it does, the three components (CLI, WEB, Launcher), and who it's for (pentesters, security teams, CI/CD pipelines).",
      "page_notes": [
        {
          "content": "BugTraceAI is NOT a wrapper around existing tools. It's an autonomous multi-agent system where AI agents discover, analyze, exploit, and validate vulnerabilities independently. The CLI is the scanning engine (Python + Go fuzzers + Playwright), the WEB is a React dashboard with 20+ security tools, and the Launcher deploys everything via Docker."
        }
      ]
    },
    {
      "title": "Architecture",
      "purpose": "High-level architecture: CLI stack (FastAPI + SQLite + LanceDB + Go fuzzers + Playwright), WEB stack (React + Express + Prisma + PostgreSQL), and how they communicate via REST API and WebSocket.",
      "page_notes": [
        {
          "content": "CLI runs on port 8000 (FastAPI). WEB frontend on port 6869 (Nginx), WEB backend on port 3001 (Express). In Full mode, WEB sends scan requests to CLI API. SQLite is the source of truth for ALL scan data. PostgreSQL is local to each WEB instance for chats and settings only. Multiple WEB instances can connect to one CLI over the network."
        }
      ]
    },
    {
      "title": "Dual Database System",
      "purpose": "Explain the two-database design: SQLite in CLI as source of truth for scans/findings, PostgreSQL in WEB for local data. Why they are separate and how they sync.",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "The origin field in SQLite marks where a scan was launched: cli, web, or unknown. Default is unknown — the system never assumes origin if it can't verify it. Design philosophy: it's OK to not know, it's bad to lie."
        }
      ]
    },
    {
      "title": "API Reference",
      "purpose": "Document the CLI REST API: scan management (CRUD, start/stop/pause/resume), findings, reports, configuration, metrics, and WebSocket streaming endpoints.",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "The repo includes an openapi.yaml file with full OpenAPI 3.1 spec. FastAPI also auto-generates Swagger UI at /docs. Key endpoints: POST /api/scans (create scan), GET /api/scans/{id}/status, GET /api/scans/{id}/findings, WebSocket /ws/scans/{id} for real-time events with reconnection support via last_seq parameter."
        }
      ]
    },
    {
      "title": "WebSocket Events",
      "purpose": "Document real-time event streaming: per-scan events (/ws/scans/{id}) and global events (/ws/global). Event types, reconnection protocol, and sequence numbers.",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "Event types: progress_update, phase_update, finding_discovered, log, scan_complete, error. Each event has a seq number. Reconnect with ?last_seq=N to replay missed events. Close code 1000 = scan complete, 1008 = invalid scan ID."
        }
      ]
    },
    {
      "title": "BugTraceAI-CLI",
      "purpose": "The autonomous security scanner. Architecture, scanning pipeline, AI agents, Go fuzzers, Playwright browser automation, and the FastAPI server.",
      "page_notes": [
        {
          "content": "CLI is a Python application with Go-compiled fuzzers (XSS, SSRF, IDOR, LFI). Uses Playwright Chromium for browser-based validation (DOM XSS, visual confirmation). AI agents use LLMs via OpenRouter API for intelligent analysis and mutation. Runs as headless server (FastAPI on port 8000) or interactive CLI."
        }
      ]
    },
    {
      "title": "Scanning Pipeline",
      "purpose": "The multi-phase scanning pipeline: Discovery, Analysis, Consolidation, Exploitation, and Validation. How URLs flow through the system.",
      "parent": "BugTraceAI-CLI",
      "page_notes": [
        {
          "content": "Phase 1 Discovery: crawl + spider target. Phase 2 Analysis: multi-persona AI analysis with consensus voting. Phase 3 Consolidation: deduplicate and prioritize findings via queues. Phase 4 Exploitation: specialized agents (XSS, SQLi, SSRF, IDOR, LFI, RCE, XXE, JWT, Open Redirect, Prototype Pollution) attempt exploitation. Phase 5 Validation: CDP browser + Vision AI screenshot analysis confirms findings."
        }
      ]
    },
    {
      "title": "Specialist Agents",
      "purpose": "Document each vulnerability specialist agent: XSS, SQLi, SSRF, IDOR, LFI, RCE, XXE, JWT, Open Redirect, Prototype Pollution. How they work, what tools they use.",
      "parent": "BugTraceAI-CLI",
      "page_notes": [
        {
          "content": "Each specialist consumes from its own queue. Agents use AI for intelligent payload mutation and context-driven pruning (CDP) to skip low-value targets. Go fuzzers handle high-speed payload delivery for XSS, SSRF, IDOR, LFI. Agents report findings with severity, confidence score, and validation status."
        }
      ]
    },
    {
      "title": "Queue and Event System",
      "purpose": "The internal queue system that distributes findings to specialist agents, and the event bus that powers real-time streaming.",
      "parent": "BugTraceAI-CLI",
      "page_notes": [
        {
          "content": "Per-specialist queues (xss, sqli, csti, lfi, idor, rce, ssrf, xxe, jwt, openredirect, prototype_pollution). Deduplication before queuing. Metrics track queue depth, throughput, latency. Event bus publishes scan events consumed by WebSocket endpoints."
        }
      ]
    },
    {
      "title": "Validation System",
      "purpose": "How findings are validated: Chrome DevTools Protocol for browser-based verification, Vision AI for screenshot analysis, confidence scoring.",
      "parent": "BugTraceAI-CLI",
      "page_notes": [
        {
          "content": "Validation statuses: PENDING_VALIDATION, VALIDATED_CONFIRMED, VALIDATED_FALSE_POSITIVE, MANUAL_REVIEW_RECOMMENDED, SKIPPED, ERROR. CDP uses headless Chromium via Playwright. Vision AI analyzes screenshots to confirm visual indicators of exploitation."
        }
      ]
    },
    {
      "title": "Report Generation",
      "purpose": "How scan reports are generated in HTML, JSON, and Markdown formats. Report structure and download via API.",
      "parent": "BugTraceAI-CLI",
      "page_notes": [
        {
          "content": "Reports available at GET /api/scans/{id}/report/{format} where format is html, json, or markdown. HTML reports include an interactive viewer. Individual report files accessible via GET /api/scans/{id}/files/{filename}."
        }
      ]
    },
    {
      "title": "Configuration",
      "purpose": "Runtime configuration via API (GET/PATCH /api/config). Safe mode, scan depth, model selection, concurrency limits, and other settings.",
      "parent": "BugTraceAI-CLI",
      "page_notes": [
        {
          "content": "Key settings: SAFE_MODE, MAX_DEPTH, MAX_URLS, model selection (DEFAULT_MODEL, CODE_MODEL, ANALYSIS_MODEL in provider/model format for OpenRouter), HEADLESS_BROWSER, EARLY_EXIT_ON_FINDING, STOP_ON_CRITICAL, REPORT_ONLY_VALIDATED. API keys are masked in GET responses."
        }
      ]
    },
    {
      "title": "BugTraceAI-WEB",
      "purpose": "The web dashboard: React frontend, Express backend, real-time scan monitoring, security toolkit, and chat-based analysis.",
      "page_notes": [
        {
          "content": "Frontend: React + Vite + TailwindCSS. Backend: Express + Prisma + PostgreSQL. Connects to CLI API for scan management and real-time monitoring via WebSocket. Stores its own chat history, analysis reports, and user settings independently in PostgreSQL."
        }
      ]
    },
    {
      "title": "Security Toolkit",
      "purpose": "The 20+ specialized security tools available in the web interface: SAST/DAST assistants, payload generators, JWT auditor, DOM XSS pathfinder, and more.",
      "parent": "BugTraceAI-WEB",
      "page_notes": [
        {
          "content": "Tools are AI-powered chat-based assistants. Each tool has a specialized system prompt. Users interact via natural language. Tools generate payloads, analyze code, audit JWT tokens, trace DOM XSS paths, etc. All analysis history is persisted in PostgreSQL."
        }
      ]
    },
    {
      "title": "Real-time Scan Monitoring",
      "purpose": "How the WEB dashboard connects to CLI WebSocket to show live scan progress, findings, and agent activity.",
      "parent": "BugTraceAI-WEB",
      "page_notes": [
        {
          "content": "WEB frontend connects to CLI's /ws/scans/{id} endpoint. Displays real-time progress bars, active agent info, phase transitions, and new findings as they appear. Supports reconnection with event replay."
        }
      ]
    },
    {
      "title": "BugTraceAI-Launcher",
      "purpose": "One-command Docker deployment wizard. Three deployment modes, auto-dependency detection, port management, and service lifecycle.",
      "page_notes": [
        {
          "content": "Install: git clone + ./launcher.sh. Interactive wizard asks deployment mode, API key, port preferences. Installs to ~/bugtraceai/ (configurable via BUGTRACEAI_DIR). No sudo required — only Docker group membership. Commands: status, start, stop, restart, update, uninstall, logs."
        }
      ]
    },
    {
      "title": "Deployment Modes",
      "purpose": "Three modes: Full Platform (WEB + CLI auto-connected), Standalone WEB (dashboard only), Standalone CLI (headless scanner only). Use cases for each.",
      "parent": "BugTraceAI-Launcher",
      "page_notes": [
        {
          "content": "Full mode auto-configures CORS and VITE_CLI_API_URL so WEB points to CLI. Standalone CLI is for CI/CD and API-only use. Standalone WEB is for manual analysis without autonomous scanning. Each stack runs its own Docker Compose project."
        }
      ]
    },
    {
      "title": "Getting Started",
      "purpose": "Quick start guide: prerequisites, one-liner install, first scan, accessing the dashboard.",
      "page_notes": [
        {
          "content": "Requirements: Docker 24.0+, Git, 4GB RAM (8GB recommended), 10GB disk, OpenRouter API key. One-liner: git clone https://github.com/BugTraceAI/BugTraceAI-Launcher.git ~/bugtraceai-launcher && ~/bugtraceai-launcher/launcher.sh. The wizard handles everything else."
        }
      ]
    }
  ]
}
